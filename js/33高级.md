# Lesson 33 JSONP

《[阮一峰：浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)》



跟后台打交道

## 预习： 数据库/历史

>**数据库**：即仓库 可以**长久存**数据的。 如文件系统/硬盘/光盘 。  可查读写 
>
>**MySQL** My作者女儿名简写。**结构化查询**语言
>
>**http协议。 请求---响应。**本地刷新变量重置----利用数据库能存储修改后的新值
>
>**付款的过程**： 请求--响应---整个页面刷新--点击返回再刷新页面出现结果余额

**优化**的历史：

> form 表单提交: **一旦提交**整个页面**刷新**。
>
> **局部刷新**： ***iframe***  :结果[表单属性***target***]加载在 iframe [***name***属性]上。
>
> 利用标签 如 a / img /script /link
>
> ***img*** 标签 ：点击按钮创建Img 元素利用其***src*** 属性发出 ***get*** 请求。响应成功/失败返回图片及状态码，利用事件***onload/onerror*** 进行相应反应。  缺点：需要返回图片、只能发出get请求
>
> ***script*** 标签：创建script 元素，利用其***src*** 属性发出 ***get*** 请求。同上，缺点：请求的script内容会执行***&***增加多script标签，可利用事件再删除标签。  好处： 不会返回图片  请求响应更快 

---



`img.src`   `img.onload`  `img.onerror `

`response.write(string) ``response.end`

`fs.readFileSync('./db','utf8')`  `fs.writeFileSync('./db',newValue)`



局部刷新历史 优化进程：不返回 HTML，返回 JS

方案1：用图片造 get 请求

``` javascript
button.addEventListener('click', (e)=>{
    let image = document.createElement('img')
    image.src = '/pay'
    image.onload = function(){ // 状态码是 200~299 则表示成功
        alert('成功')
    }
    image.onload = function(){ // 状态码大于等于 400 则表示失败
        alert('失败')
    }
})
```



方案二：用 script 造 get 请求

``` javascript
button.addEventListener('click', (e)=>{
    let script = document.createElement('script')
    script.src = '/pay'
    document.body.appendChild(script)
    script.onload = function(e){ // 状态码是 200~299 则表示成功
        e.currentTarget.remove()
    }
    script.onload = function(e){ // 状态码大于等于 400 则表示失败
        e.currentTarget.remove()
    }
})
//后端代码
...
if (path === '/pay'){
    let amount = fs.readFileSync('./db', 'utf8')
    amount -= 1
    fs.writeFileSync('./db', amount)
    response.setHeader('Content-Type', 'application/javascript')
    response.write('amount.innerText = ' + amount)
    response.end()
}
...
```

这种技术叫做 ***SRJ*** - **Server Rendered JavaScript**