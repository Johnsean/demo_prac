# Lesson 33 JSONP

《[阮一峰：浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)》



跟后台打交道

## 预习： 数据库/历史

>**数据库**：即仓库 可以**长久存**数据的。 如文件系统/硬盘/光盘 。  可查读写 
>
>
>
>**MySQL** My作者女儿名简写。**结构化查询**语言
>
>**http协议。** 请求---响应。本地刷新变量重置----利用数据库能存储修改后的新值
>
>**付款的过程**： 请求--响应---整个页面刷新--点击返回再刷新页面出现结果余额

**优化**的历史：

> 1. form 表单提交: **一旦提交**整个页面**刷新**。
>
> 2. **局部刷新**： ***iframe***  :结果[表单属性***target***]加载在 iframe [***name***属性]上。
>
> 3. 利用标签 如 a / img /script /link
>
> a.        ***img*** 标签 ：点击按钮创建Img 元素利用其***src*** 属性发出 ***get*** 请求。响应成功/失败返回图片及状态码，利用事件***onload/onerror*** 进行相应反应。  缺点：需要返回图片、只能发出get请求
>
> b.        ***script*** 标签：创建script 元素，利用其***src*** 属性发出 ***get*** 请求。同上，缺点：请求的script内容会执行***&***增加多script标签，可利用事件再删除标签。  好处： 不会返回图片  请求响应更快 

---



## 1 . 开始 请求响应

`img.src`   `img.onload`  `img.onerror `

`response.write(string) `  `response.end`

`fs.readFileSync('./db','utf8')`  `fs.writeFileSync('./db',newValue)`



### **服务器端代码**：

>三板斧  响应头 + 写入内容 +end 输出显示写入内容

``` javascript
//第三部分  根据请求路径 返回相应
if (path == '/style.js') { 
    // 第一种写法 服务器直接写数据入输出
    response.setHeader('Content-Type', 'text/css; charset=utf-8')
    response.write('body{background-color: #ddd;}h1{color: red;}') 
    response.end()

```

``` javascript
else if (path === '/') { 
    // 第二种写法 服务器读取数据写入输出
    var string = fs.readFileSync('./index.html', 'utf8')  //读取文件
    response.setHeader('Content-Type', 'text/html; charset=utf-8')
    response.end(string)  //返回文件string给浏览器
```

>else { `response.statusCode = 404` } 返回的状态码



### **不用数据库**：

点击 **-1**  但是刷新数值又会重置初始值 [代码](https://github.com/Johnsean/demo_prac/commit/fa4f31a258475994db0082b3ec66539f65393d1f?diff=unified)



### **使用**数据库存储： 

> 创建文件 ***db*** 写入 **100**
>
> ***html***用占位符 来标识 : `&&&amount&&&` [之前是使用数值100]
>
> 服务器 处理的时候 替换 -------------该文件值为字符串100

``` javascript
    // 服务器端：  读入文件==》字符串 替换html占位符 ==>输出html
    var string = fs.readFileSync('./index.html', 'utf8')
   	var amount = fs.readFileSync('./db','utf8')
    string = string.replace('&&&amount&&&',amount)  
      ...
```

服务器则存储了 数值余额100

>点击pay 时，需要向服务器请求，服务器响应 将数值修改-1 在返回

这里发出请求 使用**表单**提交  

>**表单提交特点**：一旦提交 刷新整个页面，跳转目标页面

​    模拟付款失败： 随机数

``` html
您的账户余额是<span id="amount">&&&amount&&&</span>
        <form action="/pay" method="post">
            <input type="submit" value="付款" />
        </form
```

``` javascript
// 表单跳转：  方式转大写
else if (path === '/pay' && method.toUpperCase() === 'POST') {   var amount = fs.readFileSync('./db', 'utf8')
    var newAmount = amount - 1
    if (Math.random() > 0.5) {  //模拟付款情况
      fs.writeFileSync('./db', newAmount)  //写入数据库
      response.write('success')}else {
      response.write('fail')
    }
    response.end()
  }
```

[代码：](https://github.com/Johnsean/demo_prac/commit/cdc209a107e3c7057f3b33d37ded941a74737503?diff=unified)



### **优化1** : 使用 *iFrame*

将表单提交 跳转的页面**定向**[***target***]到 ***iframe*** 上即可

``` html
 <iframe name="result" src="about:blank" frameborder="0" height="200"></iframe>
```

问题： 当前页面不刷新 所以余额需要手动刷新 /使用代码刷新才显示真正当前数额 `window.location.reload()`



### 优化2 :  局部刷新 使用标签请求

**局部刷新历史 优化进程：不返回 HTML，返回 JS**

#### 	**方案1**：用图片造 get 请求

>这种方式 **缺陷**： 没有办法设置 ***Post***

``` javascript
button.addEventListener('click', (e)=>{
    let image = document.createElement('img')
    image.src = '/pay'
    image.onload = function(){ // 状态码是 200~299 则表示成功
        alert('成功')
        amount.innerText = amount.innerText - 1 //手动局部刷新页面
    }
    image.onload = function(){ // 状态码大于等于 400 则表示失败
        alert('失败')
    }
})
```

浏览器怎么知道 ：请求成功 失败    -----------------可利用状态码

``` javascript
{  //图片方法 需要返回1*1像素大小的图片 设置头
  var newAmount = amount - 1
        ...
  response.setHeader('Content-Type', 'image/jpg')	
  response.statusCode = 200  //成功状态码 
  response.write(fs.readFileSync('./dog.jpg'))
}else {
    response.statusCode = 404  //失败状态码 
    response.write('fail')
    }
    response.end()
...
```





#### **方案二**：用 script 造 get 请求

-好处： 不会返回图片【**返回的是*script*** 并执行call()】  请求响应更快 

-缺点： 请求的***scirpt*** 加在最后面，***script***  的内容 会执行： ----先执行响应内容***scirpt*** 再执行绑定的成功/失败事件。

>script 要放入***body*** **内**才能成功使用  浏览器才会发出请求 。多余script 标签需要清除。

``` javascript
button.addEventListener('click', (e)=>{
    let script = document.createElement('script')
    script.src = '/pay'
    document.body.appendChild(script)
    script.onload = function(e){ // 状态码是 200~299 则表示成功
        debbuger   // 可以断点看
        e.currentTarget.remove() //成功只需要删除 会自动执行响应的script内容-1
    }
    script.onerror = function(e){ // 状态码大于等于 400 则表示失败
        alert('fail')
        e.currentTarget.remove()
    }
})
//后端代码  服务器端 执行script[script头+内容] ==》-1 && 刷新
...
if (path === '/pay'){
    let amount = fs.readFileSync('./db', 'utf8')
    amount -= 1  
    fs.writeFileSync('./db', amount)
    //!!! 响应返回script
    response.setHeader('Content-Type', 'application/javascript')
    response.write(`alert("success) ; amount.innerText -= amount.innerText`)
    
    response.end()
}
...
```

这种技术叫做 ***SRJ*** - **Server Rendered JavaScript**  -----服务器返回的 script



